---
title: "알고리즘 스터디를 위한 이론 정리"
date: 2022-12-12 22:00:00
category: "CS"
draft: false
---

놓을 수 없는 알고리즘 공부...

목요일 오후 9 ~ 11시, 멋사 식구인 준형이, 민선이와 알고리즘 스터디 진행하기로 하였습니다!

주차 별로 '특정 알고리즘'을 주제로 하여 문제를 가져오고, 이전 주차에서 주어졌던 문제에 대한 풀이를 함께 공유하는 자리를 가지기로 하였습니다.

내년 중순 이전까지 꼭 **알고리즘에 강점이 있는 프론트엔드 개발자**로 성장할 것입니다 🤩

해당 게시물은 앞으로 스터디를 하면서 `자료구조, 알고리즘 개념을 나만의 언어로 정리`하기 위한 게시물입니다. 약 8주간 업데이트될 예정입니다 :>

<br/>

# 그리디 알고리즘 (탐욕법)

## "현재 상황에서 가장 좋은 선택을 하는 방법. 단, 순간에서의 가장 좋은 선택만으로 문제를 해결할 수 있는지 파악해야 한다."

이름에서 느낄 수 있듯이 어떠한 문제가 주어질 때, 탐욕적인 선택을 하며 문제를 해결하는 알고리즘입니다. 이때 탐욕적이란 의미는 `현재 상황에서 당장 좋은 것만 고르는 방법`입니다. 매 순간 가장 좋은 선택을 하고, 이후에 미칠 영향에 대해선 고려하지 않는 것이죠.

이 말은 즉 문제가 주어졌을 때 `순간의 가장 좋은 선택을 해도 문제를 해결할 수 있는지 파악`해야 한다는 것입니다.

그리디 알고리즘은 문제 폭이 굉장히 넓은데, 다익스트라 알고리즘도 그리디 알고리즘에 포함되나, 해당 알고리즘에 대한 이해도가 높아야 합니다. 하지만 여기서 이야기하는 그리디 알고리즘은 알고리즘에 대한 이해도가 낮아도 풀 수 있는 문제들을 의미합니다. 구현 문제에 가깝습니다.

보통 문제에서 가장 큰 순서대로, 가장 작은 순서대로 와 같은 기준을 제시합니다. 대체로 이 기준은 정렬 알고리즘을 사용할 때 만족시킬 수 있는데, 그리디 알고리즘은 정렬 알고리즘과 짝을 이뤄 출제되는 경우가 많습니다.

# 구현

## “문제 해결 방법을 소스 코드로 정확하게 옮기기”

사소한 입력 조건 등 문제의 길이가 길다면 ‘구현’ 문제라고 의심해볼 수 있을 것입니다.

특정 프로그래밍 언어에 익숙할수록 유리하며, `다양한 조건들을 정확히 파악`하는 연습이 필요합니다. 사용하는 언어의 문자열 다루기, 리스트 다루기 … 언어에 익숙할수록 유리합니다. (책에서는 C/C++ or Java 가 불리하다고 나와있습니다. 아마도 Python, JS가 유리하지 않을까 싶어요.)

이.코.테 책에서는 완전 탐색, 시뮬레이션도 구현으로 묶어서 보고 있습니다.

# DFS / BFS

## “탐색은 많은 양의 데이터 중 원하는 데이터를 찾는 과정이며, DFS, BFS는 Graph를 탐색하기 위한 알고리즘”

DFS 는 Depth First Search를 의미하며, 그래프의 가장 깊은 곳을 우선적으로 탐색하는 것입니다. 주로 `Stack` 자료 구조로 문제를 해결할 수 있습니다.

BFS는 Breath First Search를 의미하며, 그래프의 너비를 우선적으로 탐색하는 것입니다. 주로 `Queue` 자료 구조로 문제를 해결할 수 있습니다.

그래프를 표현하기 위해선 인접 행렬 형태를 자주 사용합니다. `[[0,0,0], [0,1,0], [1,0,0]]`

또한 DFS, BFS 탐색은 그래프 특정 지점의 `x+1`, `x-1`, `y+1`, `y-1` 를 이동하며 탐색하는 로직 기반입니다.

# 최단경로

## “특정 지점까지 가장 빠르게 도달하는 방법을 찾기”

최단 경로 문제는 '한 지점에서 다른 특정 지점까지의 최단 경로를 구하는 경우', '모든 지점에서 다른 모든 지점까지의 최단 경로를 구하는 경우' 등의 사례가 존재합니다.

보통 그래프를 통해 해당 문제를 표현할 수 있습니다. 각 지점은 그래프의 `노드`로 표현되며, 연결된 도로는 `간선`으로 표시됩니다.

`다익스트라`, `플로이드 워셜`, `벨만 포드` 알고리즘 등으로 최단 경로 유형의 문제를 해결할 수 있습니다.

### 1. 다익스트라

그래프에서 여러 개의 노드가 있을 때, 특정 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구하는 알고리즘입니다. 단, `음(-)의 간선이 없을 때` 정상적으로 동작합니다.

매번 가장 작은 비용이 적은 노드를 선택하여, 임의의 과정을 반복하는 컨셉에 의해 그리디 알고리즘으로 분류됩니다.

```md
1. 출발 노드 선정
2. 최단 거리 테이블 초기화
3. 방문하지 않은 노드 중, 최단 거리가 가장 짧은 노드 선택
4. 해당 노드를 거쳐 다른 노드로 가는 비용 계산하여, 최단 거리 테이블 갱신
5. 위 과정에서 (3), (4)번을 반복
```

### 1. 플로이드 워셜

다익스트라는 하나의 정점에서 다른 모든 정점까지의 최단 거리를 구하는 알고리즘(S.S.S.P - Single Source Shortest Path) 이었다면, 플로이드 워셜 알고리즘은 한 번 실행하여 모든 노드 간 최단 경로를 구할 수 있습니다.

플로이드-워셜 알고리즘은 다익스트라 알고리즘과는 다르게 `음의 간선`도 사용할 수 있습니다.
