---
title: "Remix vs Next.js: 멘탈 모델을 통한 비교"
date: 2025-02-26
category: "front"
draft: false
---

## 서론

OpenAI 가 Next.js 를 버리고, Remix 프레임워크를 선택했다는 흥미로운 소식을 듣고 Remix 에 대해 서칭해보았습니다. 지금까지 Next.js 의 스택을 지닌 프로젝트는 종종 진행해왔지만 Remix 프레임워크는 낯선데요. 멘탈 모델을 기반으로 정리한 포스팅입니다!

## Remix vs Next.js: 멘탈 모델을 통한 비교

Remix와 Next.js는 둘 다 현대적인 JavaScript 프레임워크로, React 애플리케이션을 구축하는 데 유용하게 사용됩니다.

둘은 모두 SEO와 성능 최적화, 개발자 경험을 중시하며, 웹 애플리케이션을 더 빠르고 효율적으로 만들기 위한 많은 기능을 제공합니다. 그러나 두 프레임워크는 사용자의 멘탈 모델에 따라 다르게 접근합니다.

## Next.js: "파일 시스템 기반 라우팅 + React의 가장 쉬운 시작점"

Next.js는 매우 직관적이고 개발자가 쉽게 접근할 수 있는 프레임워크입니다. React를 기반으로 하며, 파일 시스템 기반 라우팅, 서버 사이드 렌더링(SSR), 정적 사이트 생성(SSG) 등 다양한 기능을 제공합니다. Next.js는 설정이 적고, 애플리케이션의 대부분을 자동으로 관리하는 방식으로 개발을 간소화하는 데 중점을 둡니다.

### Next.js의 멘탈 모델

Next.js를 사용할 때 개발자의 멘탈 모델은 매우 "추상화된" 경험입니다. pages 디렉터리에 React 컴포넌트를 배치하는 것만으로 라우팅이 자동으로 설정되고, 기본적으로 클라이언트-사이드와 서버-사이드 렌더링을 선택할 수 있습니다. 개발자는 코드가 어떻게 렌더링되는지 신경 쓰기보다는 파일을 작성하는 것만으로 자연스럽게 기능을 확장할 수 있습니다. 그 과정에서 자주 사용하는 패턴을 자동으로 제공하므로, 개발자는 실수나 복잡한 설정 없이 대부분의 웹 애플리케이션을 빠르게 구축할 수 있습니다.

자동화된 성능 최적화: Next.js는 페이지의 빌드를 자동으로 최적화하고, 필요한 경우 서버 측 렌더링을 사용합니다. 이로 인해 최소한의 설정으로 빠르고 효율적인 앱을 만들 수 있습니다.
파일 기반 라우팅: pages 폴더에 파일을 추가하기만 하면 자동으로 라우팅이 설정됩니다. 디렉터리 구조와 파일명이 URL로 연결되기 때문에 직관적입니다.

### 단점

Next.js는 추상화된 방식으로 설정과 기능을 제공하므로, 복잡한 애플리케이션을 만들 때 좀 더 세밀한 설정이나 커스터마이징이 필요할 수 있습니다. 또한 Next.js의 SSR과 SSG 기능은 자동으로 관리되기 때문에, 어떤 방식으로 렌더링되는지 세부적인 조정이 필요할 때 약간의 구조적 제약을 느낄 수 있습니다.

## Remix: "데이터 로딩을 더 명확하고 선언적인 방식으로"

Remix는 Next.js보다 좀 더 "직접적인" 접근을 제공합니다. Remix의 주요 철학은 서버 중심의 데이터 로딩, 불변성 유지, 빠른 응답 속도를 중시하는 것입니다. Remix는 클라이언트 사이드 라우팅에 의존하는 대신, 서버에서 데이터를 로드하고 HTML을 직접 렌더링하여 페이지를 전달하는 방식을 강조합니다. 또한 Remix는 form handling과 서버 사이드 데이터 요청을 명확하고 선언적인 방식으로 다룹니다.

### Remix의 멘탈 모델

Remix를 사용할 때 개발자는 **데이터 흐름을 명확하게 제어**하려는 마음가짐을 갖게 됩니다. Remix는 데이터 로딩과 렌더링 과정을 명확히 구분합니다. 예를 들어, 페이지에서 데이터를 로드하는 방식은 load 함수로 관리되며, 이는 서버와 클라이언트 간의 데이터 흐름을 명확하게 다루게 해줍니다. 개발자는 load 함수 안에서 데이터를 어떻게 가져올지, 그리고 이를 어떻게 렌더링할지를 더 직관적으로 이해할 수 있습니다. Remix는 응답을 직접적으로 관리하며, 이로 인해 더 명확한 데이터 흐름과 빠른 응답 속도를 제공합니다.

서버 중심의 렌더링: Remix는 데이터를 클라이언트에서 요청하지 않고, 서버에서 데이터를 미리 로드한 후 렌더링합니다. 이 방식은 빠른 페이지 응답과 SEO 최적화에 유리합니다.
명확한 데이터 로딩: Remix는 load 함수를 사용하여 각 라우트의 데이터를 명시적으로 로딩합니다. 이는 Next.js의 getServerSideProps나 getStaticProps보다 더 선언적인 방식으로 데이터를 다룰 수 있게 해줍니다.

### 단점

Remix는 설정이 더 많고, 다소 더 복잡한 접근을 필요로 합니다. 기본적인 개발 경험이 Next.js보다 약간 더 복잡할 수 있으며, 특히 세밀한 데이터 흐름을 제어하려는 개발자에게 적합합니다. 또한 Remix의 라우팅은 Next.js와 달리 URL과 라우트 간의 연관성을 명확히 정의해야 하므로, 초보자에게는 더 많은 개념적 부담을 줄 수 있습니다.

## Remix와 Next.js의 차이점

| 특성             | Next.js                                          | Remix                                                   |
| ---------------- | ------------------------------------------------ | ------------------------------------------------------- |
| 데이터 로딩 방식 | 자동화된 SSR, SSG, 클라이언트 사이드 데이터 로딩 | 서버 중심의 데이터 로딩, 명확한 데이터 흐름 제어        |
| 라우팅           | 파일 시스템 기반 라우팅                          | URL과 라우트의 관계를 명확하게 설정 (더 많은 설정 필요) |
| 개발 경험        | 설정이 간단하고 추상화가 많음                    | 데이터 흐름과 서버 사이드 로딩에 대한 명확한 접근       |
| 성능 최적화      | 자동으로 성능 최적화                             | 데이터 로딩 최적화, 서버 중심 렌더링                    |
| SEO              | 매우 좋음 (SSR과 SSG 지원)                       | 매우 좋음 (서버 사이드 렌더링을 통한 SEO 최적화)        |
| 학습 곡선        | 낮음 (자동화된 설정과 추상화된 경험)             | 약간 높음 (데이터 흐름과 설정을 직접 제어해야 함)       |

## 멘탈 모델 관점에서의 선택

- Next.js는 **간단한 시작**을 중시하는 개발자에게 적합합니다. Next.js는 자동화된 설정과 추상화를 통해 개발자가 신경 써야 할 부분을 최소화합니다. 즉, "빠르게 시작하고 결과를 얻자"는 멘탈 모델을 제공합니다. Next.js는 기본적인 애플리케이션에서 복잡한 설정을 피하면서 대부분의 일을 프레임워크가 대신 처리해주기 때문에, 개발자가 기능에 집중할 수 있도록 도와줍니다.

- Remix는 **서버와 클라이언트의 명확한 데이터 흐름을 제어**하고자 하는 개발자에게 더 적합합니다. 이 프레임워크는 데이터 로딩 및 응답 최적화에 대해 더 직접적인 제어를 제공합니다. 데이터 흐름을 명확히 하고 성능을 최적화하는 데 집중하는 개발자에게는 Remix가 더 적합할 수 있습니다. 그만큼 개발자는 세밀한 제어가 필요할 때 적합한 경험을 제공합니다.

## 결론

Next.js는 쉬운 시작과 자동화된 경험을 원하고, 빠르게 프로토타입을 만들고 싶은 개발자에게 적합합니다. 반면, Remix는 데이터 흐름을 명확하게 정의하고 서버 사이드 렌더링을 최적화하려는 개발자에게 유리한 선택이 될 것입니다.

각 프레임워크는 개발자의 목표와 프로젝트에 따라 적합하게 선택될 수 있습니다.
