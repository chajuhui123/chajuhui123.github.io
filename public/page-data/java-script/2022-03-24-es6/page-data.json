{"componentChunkName":"component---src-templates-blog-post-js","path":"/java-script/2022-03-24-es6/","result":{"data":{"site":{"siteMetadata":{"title":""}},"markdownRemark":{"id":"d8bba543-475c-53b9-986e-5150c962782f","excerpt":"JavaScript 역사 1995년 : 자바스립트의 탄생 당시 네스케이프사의 네비게이터가 웹브라우저 시장을 지배하고 있었는데,\r\n네스케이프는 HTML 페이지에 경량의 프로그램 언어를 통하여 인터렉티브 한 것을 추가 하기로 결정했다.\r\n그렇게, 브래던 아이크 (Brendan Erich…","html":"<h1>JavaScript 역사</h1>\n<h3>1995년 : 자바스립트의 탄생</h3>\n<p>당시 네스케이프사의 네비게이터가 웹브라우저 시장을 지배하고 있었는데,\r\n네스케이프는 HTML 페이지에 경량의 프로그램 언어를 통하여 <strong><em>인터렉티브</em></strong> 한 것을 추가 하기로 결정했다.\r\n그렇게, 브래던 아이크 (Brendan Erich) 를 고용했고, 그는 10일 만에 언어를 만들었다.\r\n그 언어의 이름은 ‘모카’였으며, 9월 ‘라이브스크립트’로 이름을 변경하였다. 그해 12월 네스케이프와 썬은 ‘라이브스크립트’를 <strong>‘자바스크립트’</strong> 라고 최종 이름을 결정하였다.\r\n‘모카 → 라이브스크립트 → 자바스크립트’ 로 이름이 변경된 것이다.\r\n이 자바스크립트는 네비게이터 2.0B3에 포함되었다. 하지만, 자바스크립트가 탄생한지 얼마되지 않아 자바스크립트의 파생 버전인 JScript가 등장한다.</p>\n<h3>1996년 8월 : 자바스크립트의 파편화</h3>\n<p>당시 마이크로소프트는 자바스크립트의 파생 버전 JScript를 인터넷 익스플로어 3.0 에 탑재하였다.\r\n여기서 문제점은 JavaScript와 JScript 가 <strong><em>표준화되지 못하고 일부만 호환</em></strong> 되었던 것이다. 자사 브라우저의 시장 점유율을 점유하기 위해, 각 자사의 브라우저에서만 동작하는 기능을 경쟁적으로 개발하였다.\r\n이로 인해 브라우저에 따라 웹 페이지가 정상 동작하지 않는 <strong><em>크로스 브라우징 이슈</em></strong> 가 발생하기 시작했고, 모든 브라우저에서 동작하는 웹을 개발하는 것을 어려웠다.\r\n이에 <strong><em>모든 브라우저에서 동일하게 동작하는 표준화된 자바스크립트에 대한 필요성</em></strong> 이 제기되었다.</p>\n<h3>1997년 7월 : ECMAScript 공개</h3>\n<p>1996년 11월, 넷스케이프 커뮤니케이션즈는 컴퓨터 시스템의 표준을 관리하는 비영리 표준화 기구인 <strong><em>ECMA 인터네셔널에 자바스크립트의 표준화를 요청</em></strong> 하였다. 1997년 7월 ECMA-262로 불리는 표준화된 JS 초판의 명세가 완성되었고, 상표권 문제로 자바스크립트는 ECMAScript로 명명되었다. 이후 ES3, ES5가 등장하였고, 2015년에 ES6가 등장하면서 큰 변화가 있었다.</p>\n<h3>1999년 : 서버와 브라우저의 비동기적 통신, Ajax 등장</h3>\n<p>초창기 자바스크립트는 웹 페이지의 보조적인 기능을 수행하기 위해 한정적인 용도로 사용되었다. 이 시기에 대부분 로직은 주로 웹 서버에서 실행되었고 브라우저는 서버로부터 전달받은 HTML과 CSS를 단순히 렌더링하는 수준이었다.</p>\n<p>1999년, 자바스크립트를 이용해서 **비동기적(Asynchronous)**으로 <strong>서버와 브라우저가 데이터를 교환할 수 있는 통신 기능</strong>인 **<em>Ajax(Asynchronous JavaScript and XML)가 XMLHttpRequest</em>**이라는 이름으로 등장했다.</p>\n<table>\n<thead>\n<tr>\n<th>Ajax 등장 이전</th>\n<th>Ajax 등장 이후</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>서버로부터 완전한 HTML 전송 받아, 웹 전체를 랜더링</td>\n<td>변경이 필요없는 부분은 랜더링하지 않음</td>\n</tr>\n<tr>\n<td>화면이 전환되면 서버로부터 새로운 HTML 전송 받아 웹 페이지 전체를 리랜더링</td>\n<td>서버로부터 필요한 데이터만 전송 받아 필요한 부분을 한정적으로 랜더링하는 방식</td>\n</tr>\n<tr>\n<td>불필요한 데이터 통신, 변경이 없는 부분까지 다시 랜더링</td>\n<td></td>\n</tr>\n<tr>\n<td>화면 전환시 깜빡이는 현상, 퍼포먼스 측면에서 불리</td>\n<td>빠른 퍼포먼스와 부드러운 화면 전환</td>\n</tr>\n</tbody>\n</table>\n<h3>2006년 : DOM을 쉽게 제어할 수 있는, jQuery 등장</h3>\n<h3>2008년 : V8 자바스크립트 엔진의 등장, JS 웹 개발 언어로 정착</h3>\n<p>V8 자바스크립트 엔진의 등장과 함께, 웹 서버에서 수행되던 역할들이 클라이언트(브라우저)로 이동하였고, 이로써 웹 애플리케이션에서 Front-end 영역이 주목받는 계기가 되었다.</p>\n<h3>2009년 : NodeJS 등장으로 브라우저에서 벗어나 서버 사이드 애플리케이션 개발에도 활용</h3>\n<h2>그리고 ECMAScript 2015 (ES6) 등장</h2>\n<p>ECMAScript 2015는 자바스크립트의 두 번째 주요 개정판이다. ECMAScript 2015는 ES6, ECMAScript 6으로도 알려져 있다.</p>\n<p>ES6가 주목받는 이유는 무엇일까!?</p>\n<h1>ES6 🔥</h1>\n<p>ES6가 큰 관심을 받은 이유는 단지 최신 버전이기 때문일까? ❎</p>\n<p>1997년 6월에 1판을 시작으로 불규칙적이게 개정되던 것이 2015년 부터는 매년 6월에 규칙적으로 개정이 되고 있다.</p>\n<p>특히 이 중 ES6 에서는 ES5 이하 명세에서 문제가 되었던 부분들이 해결되었고 많은 기능들이 추가되었다.</p>\n<p>이는 <strong><em>가독성과 유지보수성 향상</em></strong> 으로 이어졌다.</p>\n<ul>\n<li><strong>많은 사람들이 ES6에 주목하는 이유를 ‘아름다운 코드’를 작성하는데 이바지하였기 때문이라고 한다.</strong></li>\n</ul>\n<p>React 나 Vue 등 유명 라이브러리들도 이에 맞춰 개발 환경을 ES6로 바꾸게 되었다. 이러한 이유로 인해 사람들이 ES6에 주목하고 관심을 갖게 되었다.</p>\n<hr>\n<h3>1️⃣ var, let , const 의 차이점은 스코프</h3>\n<ul>\n<li>\n<p>ES5 이하</p>\n<ul>\n<li><code class=\"language-text\">var</code> <strong>함수 스코프</strong> (스코프는 어떤 변수들에 접근할 수 있는지 정의한 범위)를 가지며, 동일한 식별자로 재선언하면 기존 값을 덮어쓰게 됨.</li>\n<li>스코프 내에 이미 동일한 식별자를 가진 변수가 존재한다면 해당 변수를 재할당한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">var</span> i <span class=\"token punctuation\">;</span>\r\n\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">{</span>\r\n\t\t<span class=\"token comment\">// 우리의 예상 : 이 안에서만 i에 접근할 수 있음. 하지만...</span>\r\n\t<span class=\"token punctuation\">}</span>\r\n\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\t<span class=\"token comment\">// 10 -> var은 함수 스코프를 가지기 때문에 함수 내에 있는 변수에 접근 가능함.</span>\r\n\t<span class=\"token comment\">//       만약 i가 for 문 이전에 선언되었더라면, for문에서 값이 덮어씌여졌을 것이다.</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>예측 불가한 오류가 발생할 가능성이 높다</li>\n</ul>\n</li>\n<li>\n<p>ES6 ~</p>\n<ul>\n<li><code class=\"language-text\">let</code> <code class=\"language-text\">const</code> <strong>블록 스코프</strong>를 가지고, 재선언 불가</li>\n<li>재할당 가능한 변수 선언 키워드 let 과 (↔  var은 함수 스코프)</li>\n<li>상수 선언 키워드 const가 추가되었다.</li>\n<li>블록 스코프를 가지고 있다는 것은 변수를 둘러싼 블록 <code class=\"language-text\">({})</code> 안에서만 (위 예시에서 for문 같은 경우) 해당 변수에 접근할 수 있다는 것이다.\r\n→ 이는 애플리케이션의 <strong>안정성</strong>을 높여준다.</li>\n<li>기존 var 키워드만 있었을 때 보다 <strong>예측 가능한 코드</strong>를 작성 할 수 있게 되었다.</li>\n</ul>\n</li>\n</ul>\n<h3>2️⃣ 화살표 함수, 기본 파라미터</h3>\n<ul>\n<li>\n<p>화살표 함수 : 화살표 함수를 통해 코드를 짧고 효율적으로 표현할 수 있게 되었다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// ES5 이하</span>\r\n<span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> years<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">data</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">return</span> data<span class=\"token punctuation\">.</span>year <span class=\"token operator\">></span> <span class=\"token number\">2008</span>\r\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\">// ES6 ~</span>\r\n<span class=\"token keyword\">const</span> arrowReulst <span class=\"token operator\">=</span> years<span class=\"token punctuation\">.</span><span class=\"token function\">filter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">data</span> <span class=\"token operator\">=></span> data<span class=\"token punctuation\">.</span>year <span class=\"token operator\">></span> <span class=\"token number\">2008</span><span class=\"token punctuation\">)</span></code></pre></div>\n</li>\n</ul>\n<ul>\n<li>\n<p>기본 파라미터 :\r\n함수의 기본 파라미터를 셋팅해줄 수 있다.\r\n인자를 필요로 하는 함수에서 인자 없이 호출했을 때의 기본 값을 지정해주는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">testFunc</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">year <span class=\"token operator\">=</span> <span class=\"token number\">2021</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>year<span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token function\">testFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 2021</span>\r\n<span class=\"token function\">testFunc</span><span class=\"token punctuation\">(</span><span class=\"token number\">2022</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 2022</span></code></pre></div>\n</li>\n</ul>\n<h3>3️⃣ for 변수 of 배열</h3>\n<ul>\n<li><code class=\"language-text\">for 변수 in 배열</code> → 변수의 index 값을 리턴한다. (권장X)</li>\n<li><code class=\"language-text\">배열.forEach</code> → 내부에서 break 문을 사용할 수 없다. (권장X)</li>\n<li><code class=\"language-text\">for 변수 of 배열</code> → 배열의 내용 출력 가능하며, 내부에서 break 문을 사용할 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> years <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">2001</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2010</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2015</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2018</span><span class=\"token punctuation\">]</span>\r\n\r\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> year <span class=\"token keyword\">of</span> years<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>year<span class=\"token punctuation\">)</span>\r\n\r\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>year <span class=\"token operator\">==</span> <span class=\"token number\">2001</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">break</span>\r\n  <span class=\"token punctuation\">}</span>\r\n  <span class=\"token comment\">// 2001</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>→ 만약 break 문을 사용해야 하는 함수라면 for…of 문을 사용하면 좋을 것 같다.</p>\n<p>→ 속도 측면에서는 for 문이 best</p>\n<h3>4️⃣ 스프레드 연산자</h3>\n<p><code class=\"language-text\">...</code>연산자를 사용해 배열, 객체, 문자열을 다른 배열, 객체, 문자열과 결합하기가 수월해졌다.</p>\n<ul>\n<li>ES5 이하\n<ul>\n<li>기존에는 배열에서 <code class=\"language-text\">concat</code> 함수를 사용하거나 객체에 <code class=\"language-text\">assign</code> 함수를 사용하여 결합하였다</li>\n<li>assign 같은 경우는 기존 객체를 변화시켜, 예상치 못한 변화를 일으킬 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> newArr <span class=\"token operator\">=</span> arr1<span class=\"token punctuation\">.</span><span class=\"token function\">concat</span><span class=\"token punctuation\">(</span>arr2<span class=\"token punctuation\">)</span>\r\n<span class=\"token keyword\">const</span> newObj <span class=\"token operator\">=</span> Object<span class=\"token punctuation\">.</span><span class=\"token function\">assign</span><span class=\"token punctuation\">(</span>obj1<span class=\"token punctuation\">,</span> obj2<span class=\"token punctuation\">)</span> <span class=\"token comment\">// obj1에도 newObj와 같이 새로운 값이 할당된다.</span></code></pre></div>\n</li>\n</ul>\n<ul>\n<li>\n<p>ES6 ~</p>\n<ul>\n<li>다음과 같이 표현 가능하다.</li>\n<li>props 에서도 활용 가능하다. (<strong>Rest Parameter</strong>)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> newArr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>arr1<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>arr2<span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">]</span>\r\n<span class=\"token keyword\">const</span> newObj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>obj1<span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span>obj2 <span class=\"token punctuation\">}</span> <span class=\"token comment\">// 기존 객체에 변화가 생기지 않는다.</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">printYearsWithRestParameter</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span>years</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>years<span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token function\">printYearsWithRestParameter</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2001</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2010</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2015</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2018</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token comment\">// [ 2000, 2001, 2010, 2015, 2018 ]</span></code></pre></div>\n</li>\n</ul>\n<h3>5️⃣ 객체 관련</h3>\n<ul>\n<li>객체 비구조화 할당 : 객체의 프로퍼티를 꺼내 바로 사용할 수 있게 되었다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> address <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token literal-property property\">country</span><span class=\"token operator\">:</span> <span class=\"token string\">'South Korea'</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token literal-property property\">city</span><span class=\"token operator\">:</span> <span class=\"token string\">'Seoul'</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token literal-property property\">street</span><span class=\"token operator\">:</span> <span class=\"token string\">'Gangnam'</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token literal-property property\">str_num</span><span class=\"token operator\">:</span> <span class=\"token number\">141</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token literal-property property\">postcode</span><span class=\"token operator\">:</span> <span class=\"token string\">'00510'</span><span class=\"token punctuation\">,</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token comment\">// ES5 이하</span>\r\n\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">.</span>country<span class=\"token punctuation\">)</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">.</span>city<span class=\"token punctuation\">)</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>address<span class=\"token punctuation\">.</span>str_num<span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\">// ES6 ~</span>\r\n\r\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> country<span class=\"token punctuation\">,</span> city<span class=\"token punctuation\">,</span> str_num <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> address</code></pre></div>\n<ul>\n<li>객체 프로퍼티 초기화 단축 : 객체 프로퍼티 이름이 로컬 변수 이름과 같으면 콜론과 값 없이 작성해도 된다. 값을 직접 명시해주는 경우와 함께 사용할 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">getAddress</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">country<span class=\"token punctuation\">,</span> city<span class=\"token punctuation\">,</span> street</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">const</span> myAddress <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\r\n    country<span class=\"token punctuation\">,</span> <span class=\"token comment\">// country: country,</span>\r\n    city<span class=\"token punctuation\">,</span> <span class=\"token comment\">// city: city,</span>\r\n    street<span class=\"token punctuation\">,</span> <span class=\"token comment\">// street: street,</span>\r\n  <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token function\">getAddress</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Korea'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Seoul'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Euncheon'</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3>6️⃣ String 관련</h3>\n<ul>\n<li>템플릿 리터럴\n<ul>\n<li>ES5 이하 : 변수, 상수가 많아진다면 가독성이 떨어진다.</li>\n<li>ES6 ~ : 문자열 내의 변수, 상수, 줄바꿈까지 간결하게 작성할 수 있게 되었다.</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// ES5</span>\r\n<span class=\"token keyword\">var</span> str1 <span class=\"token operator\">=</span> <span class=\"token string\">', '</span>\r\n<span class=\"token keyword\">var</span> str2 <span class=\"token operator\">=</span> <span class=\"token string\">'World!'</span>\r\n<span class=\"token keyword\">var</span> str3 <span class=\"token operator\">=</span> <span class=\"token string\">'Hello'</span> <span class=\"token operator\">+</span> str1 <span class=\"token operator\">+</span> str2</code></pre></div>\n<ul>\n<li><code class=\"language-text\">includes()</code> , <code class=\"language-text\">startsWith()</code>, <code class=\"language-text\">endsWith()</code> 메소드가 추가되었다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">years<span class=\"token punctuation\">.</span><span class=\"token function\">indexOf</span><span class=\"token punctuation\">(</span><span class=\"token number\">2014</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!==</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ES5 이하</span>\r\nyears<span class=\"token punctuation\">.</span><span class=\"token function\">includes</span><span class=\"token punctuation\">(</span><span class=\"token number\">2014</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ES6 ~</span></code></pre></div>\n<h3>Promise</h3>\n<ul>\n<li>ES5 이하 : 비동기 처리를 위해 Callback 을 사용해왔다.\n<ul>\n<li>비동기 처리를 순차적으로 실행해야 하는 경우에</li>\n<li>(단점1) 비동기 처리를 중첩시켜서 표현하여 <strong>에러 및 예외처리가 어렵다</strong>는 점</li>\n<li>(단점2) <strong>중첩으로 인한 복잡도가 증가</strong>한다는 점이 있었다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">throw</span> <span class=\"token string\">'Error!'</span>\r\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span>\r\n  <span class=\"token comment\">// 에러를 만들지만 캐치하지 못한다.</span>\r\n  <span class=\"token comment\">// (setTimeout()함수의 콜백은 이벤트큐에 있다가 콜스택이 비어지면 실행되기 때문)</span>\r\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'에러를 캐치하지 못한다..'</span><span class=\"token punctuation\">)</span>\r\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n<li>ES6 ~ : 비동기에서 성공과 실패를 분리하여 메서드를 수행한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">//프로미스 생성</span>\r\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">promise1</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">param</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>param<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n      <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'resolve'</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\r\n      <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token string\">'reject'</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token punctuation\">}</span>\r\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token punctuation\">}</span>\r\n\r\n<span class=\"token comment\">//프로미스 실행</span>\r\n<span class=\"token function\">promise1</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>\r\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">result</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">)</span> <span class=\"token comment\">//resolve</span>\r\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">err</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token comment\">//reject</span>\r\n  <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>→ 성공했을 때 resolve(), 실패했을 때 reject() 를 실행한다.</p>\n<ul>\n<li>비동기 함수 중간에 에러가 난다면 <code class=\"language-text\">.then</code> <code class=\"language-text\">.catch</code> 를 통해 체이닝이 가능하다.</li>\n</ul>\n<h3>Map</h3>\n<ul>\n<li>Map() 은 자바스크립트의 key-value 쌍으로 이루어진 컬렉션</li>\n<li>key 를 사용해서 value 를 <code class=\"language-text\">get</code>, <code class=\"language-text\">set</code> 할 수 있음</li>\n<li>key 는 중복될 수 없음, 하나의 key 에는 하나의 value 만</li>\n<li>key 로 사용할 수 있는 데이터형\n<ul>\n<li>string, symbol(ES6), object, function</li>\n<li>number 는 사용할 수 없음에 주의!</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 새로운 map 을 만들고</span>\r\n\r\n<span class=\"token keyword\">let</span> me <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\n<span class=\"token comment\">// map 에 key, value 엔트리를 추가</span>\r\n\r\nme<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'juhee'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\nme<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token string\">'age'</span><span class=\"token punctuation\">,</span> <span class=\"token number\">24</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>me<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'name'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// juhee</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>me<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'age'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 24</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 대괄호를 사용해서 map 을 선언 [[KEY, VALUE], [KEY, VALUE], [KEY, VALUE]]</span>\r\n<span class=\"token keyword\">const</span> roomTypeMap <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>\r\n  <span class=\"token punctuation\">[</span><span class=\"token string\">'01'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'예시1'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token punctuation\">[</span><span class=\"token string\">'02'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'예시2'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token punctuation\">[</span><span class=\"token string\">'03'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'예시3'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token punctuation\">[</span><span class=\"token string\">'04'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'예시4'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token punctuation\">[</span><span class=\"token string\">'05'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'예시5'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\r\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>Object와의 차이?\r\nObject에서 key 는 string, 추후에 나올 Symbol 만 가능\r\nmap.size 로 바로 크기를 알 수 있다.</li>\n</ul>\n<h3>Set</h3>\n<ul>\n<li>value 로만 이루어진 컬렉션 (Array 와 비슷)</li>\n<li>Array와 차이점?\r\nvalue가 중복될 수 없다.\r\nindex가 존재하지 않지만, <code class=\"language-text\">has()</code> 를 통해 존재하는 값인지 확인할 수 있다. (indexOf 보다 연산이 빠르다고 한다)</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// Set 선언</span>\r\n<span class=\"token keyword\">let</span> setA <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\r\n\r\n<span class=\"token comment\">// 비어있는 새로운 set 을 만들고 value를 추가</span>\r\n<span class=\"token keyword\">let</span> setB <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">'a'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span>\r\nsetB<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token string\">'c'</span><span class=\"token punctuation\">)</span>\r\n\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>setB<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 3</span>\r\n\r\n<span class=\"token comment\">// has(): 주어진 값이 set 안에 존재할 경우, true 를 반환. indexOf() 보다 빠름. 단, index 가 없음</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>setB<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// true</span>\r\n\r\n<span class=\"token comment\">// set 에서 주어진 값을 제거</span>\r\nsetB<span class=\"token punctuation\">.</span><span class=\"token function\">delete</span><span class=\"token punctuation\">(</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>setB<span class=\"token punctuation\">.</span><span class=\"token function\">has</span><span class=\"token punctuation\">(</span><span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// false</span>\r\n\r\n<span class=\"token comment\">// set 안의 모든 데이터를 제거</span>\r\nsetB<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\r\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>setB<span class=\"token punctuation\">.</span>size<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 0</span></code></pre></div>\n<p>→ 중복되는 값을 포함하면 안되는 자료 구조를 작성할 때 Set 을 활용하면 적절할 것 같다.</p>\n<h3>Symbol</h3>\n<ul>\n<li>ES6에 도입된 원시 타입. 데이터의 유일함을 나타날 때 사용하며, 생성된 심볼은 다른 어떤 심볼과도 일치하지 않는다. (new 키워드를 사용하지 않는다)</li>\n<li>객체나 클래스에서 유일한 프로퍼티 만들 때 사용한다. 유일성이 보장되기에 프로퍼티 추가 시 충돌이 날 수 없으며, 의도치 않은 프로퍼티 변경을 막을 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> sym1 <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span>”key”<span class=\"token punctuation\">)</span>\r\n<span class=\"token keyword\">const</span> sym2 <span class=\"token operator\">=</span> <span class=\"token function\">Symbol</span><span class=\"token punctuation\">(</span>”key”<span class=\"token punctuation\">)</span>\r\n\r\nsym1 <span class=\"token operator\">===</span> sym2 <span class=\"token comment\">// false</span></code></pre></div>\n<h1>Array Method</h1>\n<h3>array.every(function)</h3>\n<ul>\n<li>배열 안의 모든 요소가 주어진 판별 함수 function 을 통과하는지 검사한다. Boolean 값을 return 한다.</li>\n<li>true에 대한 all 조건</li>\n<li><code class=\"language-text\">[12, 5, 8, 130, 44].every(elem => elem >= 10); // false</code></li>\n</ul>\n<h3>array.some(function)</h3>\n<ul>\n<li>하나라도 true가 발생하면 ture 를 반환한다.</li>\n<li>true에 대한 or 조건</li>\n</ul>\n<h3>array.fill(value ,start, end)</h3>\n<ul>\n<li>배열의 start 인덱스(기본값 0) 부터 end-1 (기본값 array.length) 인덱스까지 정적인 값 value로 채운다.</li>\n</ul>\n<p><code class=\"language-text\">const array1 = [1, 2, 3, 4];</code></p>\n<p><code class=\"language-text\">console.log(array1.fill(0, 2, 4)); // index 2부터 3까지 0으로 채운다.</code>\r\n<code class=\"language-text\">// expected output: [1, 2, 0, 0]</code></p>\n<p>array.flat</p>\n<p>array.flatMap</p>\n<p>array.reduce V</p>\n<p>array.reverse</p>\n<p>등 배열 자료형을 쉽게 다룰 수 있는 문법이 등장하였다.</p>\n<h1>보너스 : ES2021</h1>\n<h3>1. replaceAll</h3>\n<ul>\n<li>문자열을 한 번에 여러 개 바꿀 수 있는 기능이 추가되었다.</li>\n<li>이전에는 정규식을 통해 작성했었다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token string\">'hello,world,everyone'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">,</span><span class=\"token regex-delimiter\">/</span><span class=\"token regex-flags\">g</span></span><span class=\"token punctuation\">,</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token comment\">// 'hello world everyone'</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token string\">'hello,world,everyone'</span><span class=\"token punctuation\">.</span><span class=\"token function\">replaceAll</span><span class=\"token punctuation\">(</span><span class=\"token string\">','</span><span class=\"token punctuation\">,</span> <span class=\"token string\">' '</span><span class=\"token punctuation\">)</span>\r\n<span class=\"token comment\">// 'hello world everyone'</span></code></pre></div>\n<h3>2. Logical Assignment (||=, &#x26;&#x26;=, ??=)</h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">a <span class=\"token operator\">=</span> a <span class=\"token operator\">||</span> <span class=\"token number\">1</span>\r\n\r\nb <span class=\"token operator\">=</span> b <span class=\"token operator\">&amp;&amp;</span> <span class=\"token number\">2</span>\r\n\r\nc <span class=\"token operator\">=</span> c <span class=\"token operator\">??</span> <span class=\"token number\">3</span></code></pre></div>\n<ul>\n<li>위처럼 <code class=\"language-text\">||</code>, <code class=\"language-text\">&amp;&amp;</code>, <code class=\"language-text\">??</code> 연산을 줄여서 표기할 수 있다.</li>\n</ul>\n<h3>3. numeric separators</h3>\n<ul>\n<li>124412039120 처럼 자바스크립트에서 큰 숫자를 상수로 표시할 때는 헷갈리기 쉽다. 따라서 콤마는 아니지만 숫자 단위를 구분할 수 있는 <code class=\"language-text\">_</code> 기호가 추가되었다. 구분하고 싶은 곳에다 <code class=\"language-text\">_</code> 기호를 추가하면 된다. 소수점 아래에도 추가 가능하다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token number\">1_000_000</span>\r\n<span class=\"token number\">1_2345_2345</span>\r\n<span class=\"token number\">25.12_2364</span> <span class=\"token comment\">// 소수점 아래에서도 사용 가능</span></code></pre></div>","frontmatter":{"title":"JavaScript의 역사와 함께 알아보는, ES6의 등장","category":"javaScript","date":"March 24, 2022","description":null}},"previous":{"fields":{"slug":"/react/2022-02-21-multiple-img-preview-delete-component/"},"frontmatter":{"title":"[React] 다중 첨부 이미지 미리보기 및 제거 컴포넌트"}},"next":{"fields":{"slug":"/web/2022-05-23_HTML-Data-type/"},"frontmatter":{"title":"HTML Data-type 활용하기"}}},"pageContext":{"id":"d8bba543-475c-53b9-986e-5150c962782f","previousPostId":"05b34b64-17f6-5bab-b218-8eeb9d4402f6","nextPostId":"2f5071bf-030f-5179-8712-b074a3f83274"}},"staticQueryHashes":["2841359383","3274528899"]}