{"componentChunkName":"component---src-templates-blog-post-js","path":"/cs/2022-10-07_CS-정리-개발지식/","result":{"data":{"site":{"siteMetadata":{"title":""}},"markdownRemark":{"id":"87d65739-470c-5d2c-98b0-5ac71ea26c80","excerpt":"…","html":"<h2>1. 좋은 코드란?</h2>\n<p>‘좋은 코드’에 대한 정의는 사람들마다 다른 것 같습니다. 주로 공통적으로 언급되는 특징은 ‘읽기 쉬운 코드’, ‘중복이 없는 코드’, ‘테스트가 용이한 코드’라고 합니다.</p>\n<p>제가 생각하기에 좋은 코드는 위와 같은 특징들을 갖춰 ’<strong>업무의 생산성</strong>‘을 높여주는 코드라고 생각합니다.</p>\n<p>읽기 쉬운 변수명으로 해당 변수의 역할이 무엇일지 빠르게 파악하고, 중복되는 코드를 줄여 코드 변경시의 에러를 줄이는 등… 우선 업무에서 시간 절약이 가능합니다.</p>\n<p>좋은 코드를 위해서는 팀만의 규칙, 즉 <code class=\"language-text\">컨벤션</code>을 분명히하고, 지속적인 리뷰를 통해 서로의 코딩컨벤션을 맞추는 것이 중요하다고 생각합니다.</p>\n<h2>2. 객체 지향 프로그래밍 (Object Oriented Programming)</h2>\n<p>객체를 중심으로 하는 프로그래밍 패러다임입니다. 여기서 객체는 <strong>현실 세계의 사물</strong>이라고 할 수 있습니다.</p>\n<p>객체 지향 프로그래밍 이전의 프로그래밍 패러다임은 중심이 컴퓨터에 있었습니다. 컴퓨터가 사고하는대로 프로그래밍을 하는 것입니다.</p>\n<p>객체지향 프로그래밍이란 <code class=\"language-text\">인간 중심적 프로그래밍 패러다임</code>이라고 정리할 수 있습니다. 현실 세계를 프로그래밍으로 옮겨와 프로그래밍하는 것입니다.</p>\n<p><code class=\"language-text\">현실 세계의 사물</code>들을 <code class=\"language-text\">객체</code>라고 보고 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍 하는 것이다. 이것을 <strong>추상화</strong>라고 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span><span class=\"token punctuation\">:</span>\n    name <span class=\"token operator\">=</span> <span class=\"token string\">\"Joy\"</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">print</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">)</span>\n\nx <span class=\"token operator\">=</span> MyClass<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nx<span class=\"token punctuation\">.</span><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Developer\"</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># Joy Developer</span>\nx<span class=\"token punctuation\">.</span>name <span class=\"token comment\"># Joy</span></code></pre></div>\n<ul>\n<li>\n<p>객체 지향 프로그래밍 방식으로 코드를 작성하면 이미 작성한 코드에 대한 <strong>재사용성</strong>이 높습니다. 자주 사용되는 로직을 라이브러리로 만들어두면 지속적으로 사용할 수 있으며 신뢰성을 확보 할 수 있습니다.</p>\n</li>\n<li>\n<p>또한 라이브러리를 각종 예외상황에 맞게 잘 만들어두면 개발자가 사소한 실수를 하더라도 에러를 컴파일 단계에서 잡아낼 수 있으므로 <strong>버그 발생이 줄어</strong>듭니다.</p>\n</li>\n<li>\n<p>내부적인 동작을 몰라도 개발자는 라이브러리가 제공하는 기능들을 사용할 수 있기 때문에 <strong>생산성</strong>이 높아지게 됩니다.</p>\n</li>\n<li>\n<p>객체 단위로 코드가 나눠져 작성되기 때문에 <strong>디버깅이 쉽고 유지보수에 용이</strong>합니다.</p>\n</li>\n<li>\n<p>또한 데이터 모델링을 할 때 객체와 매핑하는 것이 수월하기 때문에 <strong>요구사항을 보다 명확하게 파악</strong>하여 프로그래밍 할 수 있습니다.</p>\n</li>\n</ul>\n<h4>객체 지향적 설계 원칙</h4>\n<ul>\n<li><strong>SRP(Single Responsibility Principle) : 단일 책임 원칙</strong>\n<ul>\n<li>클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.</li>\n</ul>\n</li>\n<li><strong>OCP(Open-Closed Principle) : 개방-폐쇄 원칙</strong>\n<ul>\n<li>확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.</li>\n</ul>\n</li>\n<li><strong>LSP(Liskov Substitution Principle) : 리스코프 치환 원칙</strong>\n<ul>\n<li>상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.</li>\n</ul>\n</li>\n<li><strong>ISP(Interface Segregation Principle) : 인터페이스 분리 원칙</strong>\n<ul>\n<li>인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.</li>\n</ul>\n</li>\n<li><strong>DIP(Dependency Inversion Principle) : 의존 역전 원칙</strong>\n<ul>\n<li>고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.</li>\n</ul>\n</li>\n</ul>\n<h2>3. RESTful API</h2>\n<p>REST란, <strong>REpresentational State Transfer</strong> 의 약자입니다. 여기에 형용사형 어미 ~ful을 붙여 ~한 API 라는 표현으로 사용됩니다. <code class=\"language-text\">REST의 기본 원칙</code>을 성실히 지킨 서비스 디자인은 ‘RESTful’하다라고 표현할 수 있다.</p>\n<p>REST는 하나의 아키텍처로 볼 수 있습니다.(‘디자인패턴이다 vs 아키텍처이다’라는 이야기가 많이 존재한다고 합니다.)</p>\n<p>REST 는 Resource Oriented Architecture 입니다(자원을 지향하는 아키텍처). <strong>API 설계의 중심에 <code class=\"language-text\">자원(Resource)</code>이 있고 <code class=\"language-text\">HTTP Method</code> 를 통해 자원을 처리하도록 설계</strong>하는 것입니다.</p>\n<h4>REST 6 가지 원칙</h4>\n<ul>\n<li>Uniform Interface</li>\n<li>Stateless</li>\n<li>Caching</li>\n<li>Client-Server</li>\n<li>Hierarchical system</li>\n<li>Code on demand</li>\n</ul>\n<h4>RESTful 하게 API 를 디자인합시다! 는 무슨 뜻일까요?</h4>\n<ul>\n<li>\n<p><strong>리소스와 행위를 명시적이고 직관적으로 분리합니다.</strong></p>\n<ul>\n<li>리소스는 <strong>URI</strong>로 표현되는데 리소스가 가리키는 것은 <strong>명사</strong>로 표현되어야 합니다.</li>\n<li>행위는 HTTP Method인, <code class=\"language-text\">GET(조회)</code>, <code class=\"language-text\">POST(생성)</code>, <code class=\"language-text\">PUT(기존 entity 전체 수정)</code>, <code class=\"language-text\">PATCH(기존 entity 일부 수정)</code>, <code class=\"language-text\">DELETE(삭제)</code> 으로 표현되어야 합니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>Message 는 Header 와 Body 를 명확하게 분리해서 사용합니다.</strong></p>\n<ul>\n<li><strong>header에는?</strong> 애플리케이션 서버가 행동할 판단의 근거가 되는 컨트롤 정보인 API 버전 정보, 응답받고자 하는 MIME 타입 등을 <code class=\"language-text\">header</code>에 담습니다.</li>\n<li><strong>body에는?</strong> Entity에 대한 내용은 <code class=\"language-text\">body</code>에 담습니다.</li>\n<li>header 와 body 는 http header 와 http body 로 나눌 수도 있고, http body 에 들어가는 json 구조로 분리할 수도 있습니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>API 버전을 관리합니다.</strong></p>\n<ul>\n<li>환경은 항상 변하기 때문에 API 의 signature 가 변경될 수도 있음에 유의합니다.</li>\n<li>특정 API 를 변경할 때는 반드시 <code class=\"language-text\">하위호환성</code>을 보장해야 합니다.</li>\n</ul>\n</li>\n<li>\n<p><strong>서버와 클라이언트가 같은 방식을 사용해서 요청하도록 합니다.</strong></p>\n<ul>\n<li>클라이언트에서는 form-data 형식의 submit 으로 보내고 서버에서는 json 형태로 보내는 식의 분리보다는, JSON 혹은 form-data 형식 중 <code class=\"language-text\">하나로 통일</code>합니다.</li>\n</ul>\n</li>\n</ul>\n<h4>RESTful API 장점</h4>\n<ul>\n<li>Open API를 제공하기 쉽다</li>\n<li>멀티플랫폼 지원 및 연동이 용이하다.</li>\n<li>원하는 타입으로 데이터를 주고 받을 수 있다.</li>\n<li>기존 웹 인프라(HTTP)를 그대로 사용할 수 있다.</li>\n</ul>\n<h4>RESTful API 장점</h4>\n<ul>\n<li>사용할 수 있는 메소드가 한정되어 있다.</li>\n<li>분산환경에는 부적합하다.</li>\n</ul>\n<h2>4. TDD (Test Driven Development)</h2>\n<p>Test-Driven Development(TDD)는 매우 짧은 개발 사이클의 반복에 의존하는 소프트웨어 개발 프로세스입니다.</p>\n<p>개발자는 요구되는 새로운 기능에 대한 자동화된 테스트케이스를 작성하고 해당 테스트를 통과하는 가장 간단한 코드를 작성한다. 일단 테스트 통과하는 코드를 작성하고 상황에 맞게 리팩토링하는 과정을 거치는 것이다. <strong>테스트가 코드 작성을 주도하는 개발방식</strong>입니다.</p>\n<p>TDD 장점은 개발자가 <strong>요구사항에 집중</strong>할 수 있게 해줍니다. 기능에 대한 요구사항에 대해 분명히 이해하고, 사용자 케이스, 스토리 등도 이해할 수 있도록 돕습니다.</p>\n<p><strong>새로운 기능을 개발할 때 무엇보다 안전</strong>합니다. feature 개발시 잘 작동하던 기능이 작동을 안하는 이슈, 이를 인식하지 못하는 이슈 등 다양한 이슈가 발생할 수 있습니다. 하지만 TDD는 이를 방지하도록 돕습니다.</p>\n<p>TDD를 위한 코드 작성시, 코드량도 늘어나고, 짧은 주기의 테스트 사이클로 인해 생산성은 떨어진다는 의견이 있습니다. 코드의 퀄리티보다 빠른 작업물 도출이 중요할 때는 TDD 방식이 선호되지 않을 것 같습니다.</p>\n<h2>5. 함수형 프로그래밍</h2>\n<p>함수형 프로그래밍의 특징은 <code class=\"language-text\">immutable data</code>와 <code class=\"language-text\">first citizen 으로서의 function</code> 입니다.</p>\n<p>immutable, 변경이 불가함을 의미합니다. 객체가 갖고 있는 값을 변경할 수 없음을 뜻하며, 값이 변경될 경우, 새로운 객체를 생성하고, 변경된 값을 주입해서 반환해야하는 것입니다.</p>\n<p>first citizen 이란 일급 객체입니다.</p>\n<ul>\n<li>일급 객체는 변수나 데이터 구조 안에 함수를 담을 수 있어, <strong>함수의 파라미터로 전달할 수 있고, 반환값으로 사용</strong>할 수 있습니다.</li>\n<li>할당에 사용된 이름과 관계없이 <strong>고유한 구별</strong>이 가능합니다</li>\n<li>함수를 <strong>리터럴로 정의</strong>할 수 있습니다.</li>\n</ul>\n<h2>4. MVC 패턴</h2>\n<p>Model-View-Controller의 아키텍처입니다. 각각은 컴포넌트로 나누어져 각각의 역할을 수행합니다.</p>\n<p><code class=\"language-text\">Model</code>은 컨트롤러가 호출할 때, 요청에 맞는 역할 수행합니다. <strong>비즈니스 로직을 구현하는 영역으로 데이터를 알맞게 처리하는 부분</strong>입니다. DB에 연결하고 데이터를 추출하거나, 저장, 삭제, 업데이트, 변환 같은 작업을 수행합니다. 상태 변화가 있을 대, 컨트롤러와 뷰에 알려주어 명령을 받을 수 있게 합니다.</p>\n<p><code class=\"language-text\">View</code>는 컨트롤러로부터 받은 모델의 결과값을 화면에 출력합니다. 만<strong>들어진 화면을 웹브라우저에 전송</strong>하는 것입니다. 사용자와의 상호작용을 위한 인터페이스를 표시하는 영역입니다.</p>\n<p><code class=\"language-text\">Controller</code>는 조정하는 영역이라고 정리할 수 있습니다. 클라이언트의 요청이 생기면, 그 요청에 대한 로직을 담당하는 모델 컴포넌트를 호출합니다. <strong>모델에 전달하기 쉽게 데이터를 가공하고, 모델의 작업이 끝나면 결과를 뷰에 전달합니다.</strong></p>\n<h2>5. Git 과 GitHub</h2>\n<p>Git은 버전 관리 시스템이며, GitHub는 버전 관리를 위한 프로젝트 저장소라고 정리할 수 있을 것입니다.</p>\n<h4>Git Flow 전략</h4>\n<p>최근 인턴 경험에서 해당 전략을 활용해 깃 버전 관리를 진행했던 경험이 있습니다 :)</p>\n<p>branch는 feature > develop > release > hotfix > master 로 정리할 수 있고 이 중 중심은 <code class=\"language-text\">master</code>와 <code class=\"language-text\">develop</code> 브랜치입니다.</p>\n<p>feature는 새로운 기능을 추가하는 브랜치입니다. develop으로부터 나오고, 반영됩니다.</p>\n<p>release는 production의 릴리즈를 위한 브랜치입니다. develop으로부터 나오고, 릴리즈가 준비되었다고 생각하면 master로 머지하는 것입니다.</p>\n<p>hotfix는 production에서 발생한 버그를 관리하는 브랜치입니다. master로부터 나오고, develop, master에 반영합니다.</p>\n<h3>GitHub Flow</h3>\n<p>브랜치와 PR 개념을 사용합니다. 자동화의 개념이 있습니다. 직관적이고 가볍다는 장점이 있습니다.</p>\n<ul>\n<li>feature/~ 브랜치를 만든다.</li>\n<li>파일을 추가하고 커밋을 한다.</li>\n<li>feature/~ 브랜치를 원격 저장소에 Push한다.</li>\n<li>GitHub에서 푸시 된 feature/~ 브랜치를 <code class=\"language-text\">Pull Request</code>한다.</li>\n<li>GitHub에서 코드리뷰를 한다.</li>\n<li>GitHub에서 Merge한다.</li>\n<li>로컬 저장소에서 원격 저장소에 머지된 내용을 Pull한다.</li>\n</ul>\n<h3>GitLab Flow</h3>\n<p>Github flow는 너무 간단해서 배포, 릴리즈 등의 조금 복잡한 이슈를 보완하기 위해 나온 전략입니다. master, production 등 기존의 전략과 브랜치명이 혼동이 있을 수 있어 유의해야합니다.</p>\n<ul>\n<li>\n<p>feature</p>\n<ul>\n<li>모든 기능 구현은 feature 브랜치에서 시작합니다. feature 브랜치는 master 브랜치에서 분기되고 머지됩니다.</li>\n</ul>\n</li>\n<li>\n<p>master</p>\n<ul>\n<li>gitlab flow의 master 브랜치 역할은 git flow의 develop 브랜치와 동일합니다. master 브랜치는 feature 브랜치에서 병합된 기능에 대해 test를 진행합니다. 전체적인 테스트가 진행되어 기능에 대한 보장이 되었다면 production 브랜치로 머지합니다.</li>\n<li>만약 staging 단계를 원한다면 pre-production 브랜치로 머지를 진행합니다.</li>\n</ul>\n</li>\n<li>\n<p>production</p>\n<ul>\n<li>gitlab flow의 production 브랜치 역할은 git flow의 master 브랜치와 동일합니다. 테스트가 끝난 기능에 대해 배포를 하기 위한 브랜치입니다.</li>\n</ul>\n</li>\n<li>\n<p>pre-production</p>\n<ul>\n<li>master → production 브랜치 사이에 pre-production 브랜치를 두어 변경 사항을 바로 production에 배포하지 않고 test server에 배포하여 통합 테스트를 진행하거나 시간을 두고 반영하는 브랜치입니다.</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"나만의 언어로 CS 지식 정리하기 : 개발 관련 지식","category":"CS","date":"October 07, 2022","description":null}},"previous":{"fields":{"slug":"/front/2022-10-06-CSR과SSR/"},"frontmatter":{"title":"SSR은 왜 주목받고 있을까?"}},"next":{"fields":{"slug":"/cs/2022-10-07-CS-정리-자료구조/"},"frontmatter":{"title":"나만의 언어로 CS 지식 정리하기 : 자료구조"}}},"pageContext":{"id":"87d65739-470c-5d2c-98b0-5ac71ea26c80","previousPostId":"0b54d179-ec4e-5ebe-8e1c-9411d01b76e5","nextPostId":"834fc29e-5181-528d-b138-8f8f7e817860"}},"staticQueryHashes":["2841359383","3274528899"]}